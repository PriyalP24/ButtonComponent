var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
/**
 * Copyright (c) 2020-present NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
import * as React from "react";
import { addons, types } from "@storybook/addons";
import { useChannel, useParameter } from "@storybook/api";
import { AddonPanel } from "@storybook/components";
import { Tab, Tabs, TabList, TabPanel } from 'react-tabs';
import 'react-tabs/style/react-tabs.css';
import * as Prism from "prismjs";
import "prismjs/components/prism-typescript";
import "prismjs/components/prism-jsx";
import "prismjs/components/prism-tsx";
import "prismjs/themes/prism.css";
import "prismjs/plugins/line-numbers/prism-line-numbers";
import "prismjs/plugins/line-numbers/prism-line-numbers.css";
import "./preview.css";
import CodeSandBox from "./CodeSandBox";
import CopyButton from "./CopyButton";
function getInfo(options, preview) {
    var template = options.template, _a = options.description, description = _a === void 0 ? "" : _a, _b = options.tab, tab = _b === void 0 ? "Code" : _b, _c = options.language, language = _c === void 0 ? "javascript" : _c;
    var text = "";
    if (typeof template === "string") {
        text = template;
    }
    else if (typeof template === "function") {
        try {
            text = template(preview || {});
        }
        catch (e) {
            text = "";
        }
    }
    return __assign(__assign({}, options), { description: description, text: text.trim(), tab: tab,
        language: language });
}
function hasKnobs(knobs) {
    var type = typeof knobs;
    if (type === "undefined") {
        return false;
    }
    if (type !== "object") {
        return true;
    }
    if (Array.isArray(knobs)) {
        return true;
    }
    for (var name_1 in knobs) {
        return true;
    }
    return false;
}
var PreviewPanel = function () {
    var _a = React.useState({}), userKnobs = _a[0], setKnobs = _a[1];
    var _b = React.useState(), preview = _b[0], setPreview = _b[1];
    var _c = React.useState(-1), defaultTabIndex = _c[0], setTabIndex = _c[1];
    var options = [].concat(useParameter("preview", []));
    var panelRef = React.useRef();
    var knobs = __assign(__assign({}, userKnobs), preview);
    useChannel({
        "preview": function (e) {
            setPreview(e);
        },
        "knobs": function (e) {
            setKnobs(e);
            setPreview(undefined);
        }
    });
    options.forEach(function (o) {
        var optionKnobs = o.knobs;
        if (optionKnobs) {
            for (var name_2 in optionKnobs) {
                knobs[name_2] = optionKnobs[name_2];
            }
        }
    });
    var templates = options
        .filter(function (option) { return "template" in option; })
        .map(function (option) { return getInfo(option, userKnobs); });
    var previews = [];
    var templateMap = {};
    templates.forEach(function (template) {
        var tab = template.tab, codesandbox = template.codesandbox;
        if (!templateMap[tab]) {
            templateMap[tab] = [];
            previews.push({
                codesandbox: codesandbox,
                tab: tab,
                templates: templateMap[tab]
            });
        }
        templateMap[tab].push(template);
    });
    var previewMap = {};
    for (var name_3 in templateMap) {
        previewMap[name_3] = templateMap[name_3].map(function (template) { return template.text; });
    }
    var tabIndex = Math.max(0, Math.min(defaultTabIndex, previews.length));
    var onCopyText = function (tab, index) {
        var copyPreview = previews[tab];
        if (!copyPreview) {
            return "";
        }
        var texts = [];
        copyPreview.templates.slice(index).every(function (template, i) {
            if (i > 0 && !template["continue"]) {
                return false;
            }
            var text = template.text;
            if (text) {
                texts.push(text);
            }
            return true;
        });
        return texts.join("\n");
    };
    React.useEffect(function () {
        var panelElement = panelRef.current;
        if (!panelElement) {
            return;
        }
        var codeElements = [].slice.call(panelElement.querySelectorAll("pre code"));
        var p = previews[tabIndex];
        if (!p) {
            codeElements.forEach(function (codeElement) {
                codeElement.innerHTML = "";
            });
            return;
        }
        var startNumber = 1;
        codeElements.forEach(function (codeElement, i) {
            var template = p.templates[i];
            var text = template.text || "";
            var code = text.replace(/</g, "&lt;");
            if (!template["continue"]) {
                startNumber = 1;
            }
            codeElement.parentElement.setAttribute("data-start", startNumber);
            codeElement.innerHTML = code;
            Prism.highlightElement(codeElement);
            startNumber += code.split("\n").length;
        });
    });
    return (React.createElement(Tabs, { className: ["react-tabs", "preview-tabs"], onSelect: function (index) {
            setTabIndex(index);
        } },
        React.createElement(TabList, null, previews.map(function (_a) {
            var tab = _a.tab;
            return React.createElement(Tab, { key: tab }, tab);
        })),
        previews.map(function (_a, i) {
            var codesandbox = _a.codesandbox, tab = _a.tab, previewTemplates = _a.templates;
            return (React.createElement(TabPanel, { key: tab },
                React.createElement("div", { className: "panel", ref: panelRef },
                    codesandbox && React.createElement(CodeSandBox, { info: typeof codesandbox === "function" ? codesandbox(previewMap) : codesandbox }),
                    previewTemplates.map(function (_a, j) {
                        var language = _a.language, description = _a.description, copy = _a.copy;
                        return React.createElement("div", { className: "code-preview", key: j },
                            copy && React.createElement(CopyButton, { tab: i, index: j, onCopyText: onCopyText }),
                            description && React.createElement("div", { className: "code-description" }, description),
                            React.createElement("pre", { className: "language-" + language + " line-numbers", style: {
                                    backgroundColor: "transparent"
                                } },
                                React.createElement("code", { className: "language-" + language + " line-numbers" })));
                    }))));
        })));
};
addons.register("naver/storyboook-addon-preview", function (api) {
    addons.add("naver/storyboook-addon-preview/panel", {
        title: "Code Preview",
        type: types.PANEL,
        paramKey: "preview",
        render: function (_a) {
            var active = _a.active, key = _a.key;
            return (React.createElement(AddonPanel, { active: active, key: key },
                React.createElement(PreviewPanel, null)));
        }
    });
});
//# sourceMappingURL=register.js.map