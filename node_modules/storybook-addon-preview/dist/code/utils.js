/**
 * Copyright (c) 2020-present NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import { CODE_TYPE } from "./consts";
function replaceOnce(func, regx, callback) {
    var isFirst = true;
    return func.replace(regx, function (all) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (!isFirst) {
            return all;
        }
        isFirst = false;
        return callback.apply(void 0, __spreadArrays([all], args));
    });
}
export function removeThis(func) {
    return func.replace(/this\./g, "");
}
export function toArrow(func) {
    return removeThis(toClassArrow(func));
}
export function toClassArrow(func) {
    return replaceOnce(func, /function ([^(]+)([^)]+\))/g, function (_, a1, a2) { return a2 + " =>"; });
}
export function toArrowMethod(func) {
    return replaceOnce(func, /function ([^(]+)([^)]+\))/g, function (_, a1, a2) { return a1 + " = " + a2 + " =>"; });
}
export function toMethod(func) {
    return func.replace("function ", "");
}
export function toCustomEvent(func) {
    return removeThis(replaceOnce(func, /\(([^)]*)\) (=>\s)?\{/g, function (_, a1, a2) {
        if (a1) {
            return "({ detail: " + a1 + " }) " + (a2 || "") + "{";
        }
        else {
            return "() " + (a2 || "") + "{";
        }
    }));
}
export function removeBracket(func) {
    return replaceOnce(func, /(\([^)]+\))\s?=>\s?\{/g, function (all, a1) {
        return /\{|\}|\,/g.exec(a1) ? all : a1.replace(/\(|\)/g, "") + " => {";
    });
}
export function includeComment(func, comment, external) {
    if (external === void 0) { external = ""; }
    return func.replace(new RegExp("\\/\\/" + comment + "(?:-([^\\s]*))*\\s", "g"), function (all, type) {
        if ((type && external && type.indexOf(external) > -1)) {
            return all;
        }
        return "";
    });
}
export function convertFunction(func, type, comment) {
    switch (type) {
        case CODE_TYPE.FUNCTION:
            return removeThis(func);
        case CODE_TYPE.ARROW:
            return removeBracket(toArrow(func));
        case CODE_TYPE.CLASS_ARROW:
            return includeComment(removeBracket(toClassArrow(func)), "method", comment);
        case CODE_TYPE.ARROW_METHOD:
            return includeComment(removeBracket(toArrowMethod(func)), "method", comment);
        case CODE_TYPE.METHOD:
            return includeComment(toMethod(func), "method", comment);
        case CODE_TYPE.CUSTOM_EVENT_ARROW:
            return removeBracket(toCustomEvent(toArrow(func)));
        case CODE_TYPE.CUSTOM_EVENT_FUNCTION:
            return toCustomEvent(func);
        case CODE_TYPE.CUSTOM_EVENT_CLASS_ARROW:
            return includeComment(removeBracket(toCustomEvent(toClassArrow(func))), "method", comment);
        case CODE_TYPE.CUSTOM_EVENT_ARROW_METHOD:
            return includeComment(removeBracket(toCustomEvent(toArrowMethod(func))), "method", comment);
        default:
            return func;
    }
}
export function previewFunction(func) {
    return function (type, comment) {
        if (comment === void 0) { comment = ""; }
        var rv = convertFunction(func, type, comment);
        rv = includeComment(rv, "", comment);
        rv = includeComment(rv, comment);
        // remove all comments
        rv = rv.replace(new RegExp("\\\n\\s*\\/\\/[^\\n]*$", "mg"), "");
        return rv;
    };
}
export function space(indent) {
    var texts = [];
    for (var i = 0; i < indent; ++i) {
        texts.push(" ");
    }
    return texts.join("");
}
export function codeIndent(text, _a) {
    var _b = _a.startIndent, startIndent = _b === void 0 ? 0 : _b, _c = _a.indent, indent = _c === void 0 ? 4 : _c, _d = _a.endIndet, endIndet = _d === void 0 ? indent : _d;
    var texts = text.trim().split("\n");
    var length = texts.length;
    return texts.map(function (t, i) {
        return space(i === 0 ? startIndent : (i === length - 1 ? endIndet : indent)) + t;
    }).join("\n");
}
export function convertGlobalCSS(text, targets) {
    return text.replace(new RegExp("(" + targets.map(function (target) {
        return target.replace(/\./g, "\\.");
    }).join("|") + ")", "g"), ":global($1)");
}
//# sourceMappingURL=utils.js.map